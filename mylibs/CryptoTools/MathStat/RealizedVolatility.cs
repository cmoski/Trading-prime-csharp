using System;
using System.Collections.Generic;
using System.Linq;
using CryptoTools.Models;
using static CryptoTools.Global;

namespace CryptoTools.MathStat
{
    public class RealizedVolatility
    {
		//public decimal Value => (decimal)(Math.Sqrt(Rterm()));
		public decimal Value => (decimal)(100.0 * Math.Sqrt(m_numerator / (double)m_nbars * Rterm()));
		public decimal StdDev => Value / (decimal) Math.Sqrt(m_numerator);
        
		public SortedDictionary<DateTime, decimal> RangeStdValues => m_rangeStdValues ?? GetRangeStdValues();
		public SortedDictionary<DateTime, XCandle> CandleMap => m_candleMap;

		private SortedDictionary<DateTime, decimal> m_rangeStdValues;
		private SortedDictionary<DateTime, XCandle> m_candleMap;
		private List<XCandle> m_candleList;

		private IEnumerable<XCandle> m_candles;
		private int m_nbars;
		private double m_numerator;

        // For DAILY, leave numerator as default value of 252. For other time periods, adjust accordingly.
        public RealizedVolatility(IEnumerable<XCandle> candles, int numberOfBars, int numerator = 252)
        {
			m_candles = candles.OrderBy(c => c.Timestamp);
			m_nbars = numberOfBars;
			m_numerator = numerator;

			m_candleList = m_candles.ToList();

			m_candleMap = new SortedDictionary<DateTime, XCandle>();
            foreach (var c in m_candles)
            {
                m_candleMap[c.Timestamp] = c;
            }
        }
        
        // Given a price (i.e. last-traded price) and the number of standard deviations (both pos/neg for normal dist)
		// Return in out variables low/high price of the range
		public void Range(out decimal lowPrice, out decimal highPrice, decimal price, decimal n_stddevs = 2.0M)
		{
			var stdValue = StdDev / 100.0M * price;
			lowPrice = price - n_stddevs * stdValue;
			highPrice = price + n_stddevs * stdValue;
		}

		// Given a price (i.e. last-traded price) and the number of standard deviations (both pos/neg for normal dist)
        // Return height of the range generated by the given price and given number of standard deviations
        public decimal RangeHeight(decimal price, decimal n_stddevs = 2.0M)
        {
            var stdValue = StdDev / 100.0M * price;
			return 2 * n_stddevs * stdValue;            // multiply by 2 because stddev is both UP and DOWN (in a normal distribution)
        }

        private double Rterm()
		{
			var arr = m_candles.Skip(m_candles.Count() - m_nbars).ToList();   // TakeLast(m_nbars).ToList();
			double sum = 0.0;
			for (int i = 1; i < m_nbars; ++i)
			{
				double d0 = (double)arr[i].ClosePrice;      // d[t]
				double d1 = (double)arr[i - 1].ClosePrice;  // d[t-1]
				sum += Math.Pow(Math.Log(d0 / d1), 2.0);
				//Console.WriteLine("{0} - {1}", d0, d1);
			}
			return sum;
		}
        
        // where i1 is index into the sorted candles iteration
		private KeyValuePair<DateTime, double> GetValue(int i1)
		{
            double sum = 0.0;
            for (int i = i1; i < i1 + m_nbars; ++i)
            {
                double d0 = (double)m_candleList[i].ClosePrice;      // d[t]
				double d1 = (double)m_candleList[i - 1].ClosePrice;  // d[t-1]
                sum += Math.Pow(Math.Log(d0 / d1), 2.0);
                //Console.WriteLine("{0} - {1}", d0, d1);
            }
			var realizedVol = (100.0 * Math.Sqrt(m_numerator / (double)m_nbars * sum));
			return new KeyValuePair<DateTime, double>(m_candleList[i1 + m_nbars - 1].Timestamp, realizedVol);
		}
        
		private SortedDictionary<DateTime, decimal> GetRangeStdValues()
        {
			m_rangeStdValues = new SortedDictionary<DateTime, decimal>();
            
			for (int i = 1; i < m_candleList.Count - m_nbars + 1; ++i)
            {
				var kv = GetValue(i);
				var ts = kv.Key;
				var rvol = kv.Value;
				var candle = m_candleMap[ts];
				//var price = candle.ClosePrice;
				var price = candle.OpenPrice;
				var stddev = rvol / Math.Sqrt(m_numerator);
				var stdValue = stddev / 100.0 * (double)price;
				m_rangeStdValues[ts] = (decimal) stdValue;
            }
			return m_rangeStdValues;
        }

        

    } // end of class RealizedVol

} // end of namespace
